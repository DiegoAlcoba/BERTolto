services:
  reverse-proxy:
    image: caddy:2
    restart: unless-stopped
    ports: [ "80:80","443:443" ]
    volumes:
      - ./caddy/Caddyfile:/etc/caddy/Caddyfile
      - caddy_data:/data
      - caddy_config:/config
    depends_on:
      - n8n
      - nocodb
    networks: [internal]

  postgres:
    image: postgres:16
    volumes:
      - ./data/db_storage:/var/lib/postgresql/data
      - ./data/db_init:/docker-entrypoint-initdb.d
    environment:
      - POSTGRES_USER=${PG_SUPERUSER}
      - POSTGRES_PASSWORD=${PG_SUPERPASS}
      #- POSTGRES_DB=n8n -> se crea directamente antes de levantar en ./data/db_init
    healthcheck:
      test: ["CMD-SHELL","pg_isready -U ${PG_SUPERUSER}"]
      interval: 10s
      timeout: 5s
      retries: 10
    networks: [internal]
    restart: unless-stopped

  redis:
    image: redis/redis-stack-server:latest
    container_name: redis
    restart: unless-stopped
    command: [ "redis-server","--requirepass","${REDIS_PASS}" ]
    volumes:
      - ./data/redis_storage:/data
    healthcheck:
      test: [ 'CMD', 'redis-cli', "-a", "${REDIS_PASS}",'ping' ]
      interval: 5s
      timeout: 5s
      retries: 10
    networks: [internal]

  n8n:
    image: docker.n8n.io/n8nio/n8n:latest
    restart: unless-stopped
    environment:
      N8N_HOST: ${N8N_HOST} # ej:n8n.ip-publica-azure.nip.io
      N8N_PROTOCOL: https
      N8N_PORT: 5678
      WEBHOOK_URL: https://${N8N_HOST}/
      N8N_BASIC_AUTH_ACTIVE: "true"
      N8N_BASIC_AUTH_USER: ${N8N_BASIC_USER}
      N8N_BASIC_AUTH_PASSWORD: ${N8N_BASIC_PASS}
      N8N_ENCRYPTION_KEY: ${N8N_ENCRYPTION_KEY}
      DB_TYPE: postgresdb
      DB_POSTGRESDB_HOST: postgres
      DB_POSTGRESDB_PORT: 5432
      DB_POSTGRESDB_DATABASE: n8n
      DB_POSTGRESDB_USER: n8n
      DB_POSTGRESDB_PASSWORD: ${PG_N8N_PASS}
      EXECUTIONS_MODE: regular  #cambiar a queue si colas lentas/webhooks concurresntes/mucha complejidad en general
      #QUEUE_BULL_REDIS_HOST: redis # Esto para qué sirve?????
      #QUEUE_BULL_REDIS_PORT: 6379
      #QUEUE_BULL_REDIS_PASSWORD: ${REDIS_PASS}
      NODE_FUNCTION_ALLOW_EXTERNAL: axios,qs,redis #Librerías que se van a poder ejecutar en Codes
      N8N_LOG_LEVEL: info
      TZ: Europe/Madrid
      GENERIC_TIMEZONE: Europe/Madrid
      # Runners -> Si al final no los uso, eliminar
      #OFFLOAD_MANUAL_EXECUTIONS_TO_WORKERS: "true" #Habilita task runners -> Si se van a utilizar se queda
      #N8N_RUNNERS_ENABLED: true  #Los _RUNNERS_ igual que arriba
      #N8N_RUNNERS_MODE: external
      #N8N_RUNNERS_BROKER_LISTEN_ADDRESS: 0.0.0.0
      #N8N_RUNNERS_AUTH_TOKEN: ${RUNNERS_TOKEN}
      #N8N_NATIVE_PYTHON_RUNNER: "true"
    volumes:
      - ./data/n8n_storage:/home/node/.n8n
      #- ./data/n8n_runners/n8n-task-runners.json:/etc/n8n-task-runners.json
      #- ./data/n8n_etc:/etc
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks: [internal]
    logging:
      driver: "json-file"
      options: { max-size: "50m", max-file: "3" }

  #task-runners:
  #  # image: n8nio/runners:1.111.0
  #  image: n8nio/runners:1.61.0
  #  restart: unless-stopped
  #  environment:
  #    N8N_RUNNERS_TASK_BROKER_URI: http://n8n:5679
  #    N8N_RUNNERS_AUTH_TOKEN: ${RUNNERS_TOKEN}
  #    N8N_RUNNERS_LAUNCHER_LOG_LEVEL: debug
  #  volumes:
  #    - ./data/n8n_task_runner:/home/node/.n8n
  #  depends_on:
  #    - n8n
  #  networks: [internal]

  nocodb:
    image: "nocodb/nocodb:latest"
    restart: unless-stopped
    environment:
      # Y la dirección para acceso desde navegador como con n8n?
      NC_DB: "pg://postgres:5432?u=nocodb&p=${PG_NOCO_PASS}&d=noco_db"
      NC_PUBLIC_URL: https://${NOCO_HOST}/
      NC_ALLOW_LOCAL_HOOKS: true
      NC_REDIS_URL: redis://:${REDIS_PASS}@redis:6379/4
    volumes:
      - "./data/nocodb_data:/usr/app/data"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks: [internal]
    logging:
      driver: "json-file"
      options: { max-size: "50m", max-file: "3" }

  model-api:
    build:
      context: ./model_api
      dockerfile: Dockerfile
    restart: unless-stopped
    environment:
      MODEL_PATH: /models/bertolto_v1
      OMP_NUM_THREADS: "1"         # empiezo en 1; subo a "2" solo si veo CPU con baja carga durantte ejecución
      MKL_NUM_THREADS: "1"         # idem
      TORCH_NUM_THREADS: "1"       # explícalo para PyTorch
      TOKENIZERS_PARALLELISM: "false"  # evita threads extra del tokenizer HF
      TZ: Europe/Madrid
    volumes:
      - ./models:/models:ro
    #Sin ports: se invoca desde n8n via http://model-api:8000
    networks: [internal]

  redisinsight:
    image: redis/redisinsight:latest
    container_name: redisinsight
    #ports:
    #  - "5540:5540"
    volumes:
      - ./data/redisinsight_storage:/data:rw
    depends_on:
      redis:
        condition: service_healthy
    networks: [internal]
    restart: unless-stopped

networks:
  internal: {}

volumes:
  caddy_data:
  caddy_config: